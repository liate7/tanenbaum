open! Common

let year = 2025
let day = 7

let example =
  ".......S.......\n\
   ...............\n\
   .......^.......\n\
   ...............\n\
   ......^.^......\n\
   ...............\n\
   .....^.^.^.....\n\
   ...............\n\
   ....^.^...^....\n\
   ...............\n\
   ...^.^...^.^...\n\
   ...............\n\
   ..^...^.....^..\n\
   ...............\n\
   .^.^.^.^.^...^.\n\
   ...............\n"

(* You quickly locate a diagram of the tachyon manifold (your puzzle input). A tachyon beam
   enters the manifold at the location marked S; tachyon beams always move downward. Tachyon
   beams pass freely through empty space (.). However, if a tachyon beam encounters a splitter
   (^), the beam is stopped; instead, a new tachyon beam continues from the immediate left and
   from the immediate right of the splitter.

   To repair the teleporter, you first need to understand the beam-splitting properties of the
   tachyon manifold.

   Analyze your manifold diagram. How many times will the beam be split? *)

(* In this example, the incoming tachyon beam (|) extends downward from S until it reaches the
   first splitter:

   .......S.......
   .......|.......
   .......^.......
   ...............
   ......^.^......
   ...............
   .....^.^.^.....
   ...............
   ....^.^...^....
   ...............
   ...^.^...^.^...
   ...............
   ..^...^.....^..
   ...............
   .^.^.^.^.^...^.
   ...............

   At that point, the original beam stops, and two new beams are emitted from the splitter:

   .......S.......
   .......|.......
   ......|^|......
   ...............
   ......^.^......
   ...............
   .....^.^.^.....
   ...............
   ....^.^...^....
   ...............
   ...^.^...^.^...
   ...............
   ..^...^.....^..
   ...............
   .^.^.^.^.^...^.
   ...............

   Those beams continue downward until they reach more splitters:

   .......S.......
   .......|.......
   ......|^|......
   ......|.|......
   ......^.^......
   ...............
   .....^.^.^.....
   ...............
   ....^.^...^....
   ...............
   ...^.^...^.^...
   ...............
   ..^...^.....^..
   ...............
   .^.^.^.^.^...^.
   ...............

   At this point, the two splitters create a total of only three tachyon beams, since they are
   both dumping tachyons into the same place between them:

   .......S.......
   .......|.......
   ......|^|......
   ......|.|......
   .....|^|^|.....
   ...............
   .....^.^.^.....
   ...............
   ....^.^...^....
   ...............
   ...^.^...^.^...
   ...............
   ..^...^.....^..
   ...............
   .^.^.^.^.^...^.
   ...............

   This process continues until all of the tachyon beams reach a splitter or exit the manifold:

   .......S.......
   .......|.......
   ......|^|......
   ......|.|......
   .....|^|^|.....
   .....|.|.|.....
   ....|^|^|^|....
   ....|.|.|.|....
   ...|^|^|||^|...
   ...|.|.|||.|...
   ..|^|^|||^|^|..
   ..|.|.|||.|.|..
   .|^|||^||.||^|.
   .|.|||.||.||.|.
   |^|^|^|^|^|||^|
   |.|.|.|.|.|||.|

   In this example, a tachyon beam is split a total of 21 times. *)

module Tachyon_manifold = struct
  module IntSet : sig
    include Set.S with type elt = Int.t

    val pp_hum : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]
  end = struct
    include Set.Make (Int)

    let pp_hum f t = Format.fprintf f "%s" @@ to_string Int.to_string t
  end

  type t = { start : int; splits : IntSet.t list }

  let of_string str =
    let start, lines =
      str |> String.lines
      |> List.drop_while ~f:(fun l -> not @@ String.contains l 'S')
      |> List.hd_tl
    in
    let start = String.find ~sub:"S" start in
    let splits =
      Iter.(
        of_list lines
        |> filter ~f:(Fun.flip String.contains '^')
        |> map ~f:(String.find_all_l ~sub:"^")
        |> map ~f:IntSet.of_list |> to_list)
    in
    { start; splits }

  let tick (count, beams) splits =
    let to_split = IntSet.inter beams splits
    and continue = IntSet.diff beams splits in
    ( count + IntSet.cardinal to_split,
      Iter.(
        to_split |> IntSet.to_iter
        |> flat_map_l ~f:(fun x -> [ x - 1; x + 1 ])
        |> IntSet.add_iter continue) )

  let run { start; splits } =
    splits |> List.fold_left ~init:(0, IntSet.singleton start) ~f:tick

  let splits t = run t |> fst
end

module Part_1 = struct
  let parse = Tachyon_manifold.of_string
  let unparse = Int.to_string
  let go = Tachyon_manifold.splits

  let run (input : string) : (string, string) result =
    Result.guard_str @@ fun () -> parse input |> go |> unparse
end

(* Problem description update *)

(* Example run-through, again *)

module Part_2 = struct
  let parse = Fun.id
  let unparse = Fun.id
  let go = Fun.id

  let run (input : string) : (string, string) result =
    Result.guard_str @@ fun () -> parse input |> go |> unparse
end
